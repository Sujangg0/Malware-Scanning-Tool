import tkinter as tk
from tkinter import filedialog, messagebox, simpledialog, ttk
import os
import yara
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
import time
import threading

# Handler for file system events to update the TreeView
class MyHandler(FileSystemEventHandler):
    def __init__(self, treeview, scanner):
        super().__init__()
        self.treeview = treeview
        self.scanner = scanner

    # Log file system events in the TreeView
    def log_event(self, action, path):
        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
        item_id = self.treeview.insert("", tk.END, values=(action, path, timestamp))
        self.treeview.see(item_id)

    def on_created(self, event):
        self.log_event("Created", event.src_path)
        # Scan the newly created file
        if os.path.isfile(event.src_path):
            self.scanner.scan_file(event.src_path)

    def on_deleted(self, event):
        self.log_event("Deleted", event.src_path)

    def on_modified(self, event):
        self.log_event("Modified", event.src_path)
        # Scan the newly created file
        if os.path.isfile(event.src_path):
            self.scanner.scan_file(event.src_path)

    def on_moved(self, event):
        self.log_event(f"Moved to {event.dest_path}", event.src_path)
        # Scan the moved file
        if os.path.isfile(event.src_path):
            self.scanner.scan_file(event.dest_path)

# Start observing a directory for file system events
def start_observing(treeview):
    global observer, monitoring_thread
    if not path:
        messagebox.showwarning("Warning", "Please select a directory to monitor before starting.")
        return

    if observer and observer.is_alive():
        messagebox.showwarning("Warning", "Monitoring is already running.")
        return

    # Create an event handler and start the observer thread
    event_handler = MyHandler(treeview, scanner)
    observer = Observer()
    observer.schedule(event_handler, path, recursive=True)

    def run_observer():
        try:
            observer.start()
            while not stop_event.is_set():
                time.sleep(1)
        finally:
            observer.stop()
            observer.join()

    stop_event.clear()
    monitoring_thread = threading.Thread(target=run_observer)
    monitoring_thread.start()
    status_var.set("Monitoring started")

# Stop observing the directory and clean up
def stop_observing():
    global stop_event
    stop_event.set()
    if observer:
        observer.stop()
        observer.join()
    if monitoring_thread and monitoring_thread.is_alive():
        monitoring_thread.join()
    status_var.set("Monitoring stopped")
    messagebox.showinfo("Stopped", "Monitoring has been stopped.")

# Class to manage malware scanning with YARA rules
class MalwareScanner:
    def __init__(self, rules_directory):
        self.rules_directory = rules_directory
        self.rules = self.compile_yara_rules_from_directory()

    # Compile YARA rules from the specified directory
    def compile_yara_rules_from_directory(self):
        try:
            yara_files = [os.path.join(self.rules_directory, f) for f in os.listdir(self.rules_directory) if f.endswith('.yar')]
            if not yara_files:
                raise ValueError("No YARA rule files found in the specified directory.")
            rules = yara.compile(filepaths={f: f for f in yara_files})
            return rules
        except yara.Error as e:
            messagebox.showwarning("YARA Error", f"Error compiling YARA rules: {e}")
            return None
        except ValueError as e:
            messagebox.showwarning("Value Error", str(e))
            return None
        except Exception as e:
            messagebox.showwarning("Error", f"An unexpected error occurred: {e}")
            return None

    # Scan a single file for malicious content
    def scan_file(self, file_path):
        try:
            with open(file_path, 'rb') as file:
                data = file.read()
                matches = self.rules.match(data=data)
                if matches:
                    alert_message = f"Malicious file detected: {file_path}\n\nMatched rules:\n"
                    for match in matches:
                        alert_message += f"Rule: {match.rule}, Strings: {match.strings}\n"
                    messagebox.showwarning("Malicious File Detected", alert_message)
                    return True
                
        except Exception as e:
            messagebox.showwarning("File Scan Error", f"Error scanning file {file_path}: {e}")
        return False

    # Scan all files in a directory
    def scan_directory(self, directory_path):
        malicious_content_found = False  # Flag to track if any malicious content is found
        try:
            for root, dirs, files in os.walk(directory_path):
                for file in files:
                    file_path = os.path.join(root, file)
                    if self.scan_file(file_path):
                        malicious_content_found = True

        except Exception as e:
            messagebox.showwarning("Directory Scan Error", f"Error scanning directory {directory_path}: {e}")

        if not malicious_content_found:
            messagebox.showinfo("Scan Result", "No malicious content detected in the directory.")

# Main GUI function
def GUI():
    global path, status_var, observer, monitoring_thread, stop_event
    path = None
    observer = None
    monitoring_thread = None
    stop_event = threading.Event()

    root = tk.Tk()
    root.geometry('850x600')
    root.title('Anti-virus')

    file_dir_name_label = None

    # Page for scanning files or directories
    def scan_page():
        nonlocal file_dir_name_label

        scan_frame = tk.Frame(main_frame)
        scan_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        lb = tk.Label(scan_frame, text='Scanner', font=('Bold', 30))
        lb.pack(pady=20)

        file_lb = tk.Label(scan_frame, text='Select File or Folder to Scan:', font=('Bold', 10))
        file_lb.pack()

        # Choose a file or directory to scan
        def choose_file_or_directory():
            nonlocal file_dir_name_label

            if file_dir_name_label:
                file_dir_name_label.destroy()

            choice = simpledialog.askstring("Select Type", "Enter '1' to select a file or '2' to select a folder:")

            if choice == '1':
                file_dir_path = filedialog.askopenfilename(title="Select File", filetypes=[("All files", "*.*")])
            elif choice == '2':
                file_dir_path = filedialog.askdirectory(title="Select Folder")
            else:
                messagebox.showwarning("Invalid Choice", "You must enter '1' for file or '2' for folder.")
                return

            if file_dir_path:
                file_dir_name_label = tk.Label(scan_frame, text=file_dir_path, font=(10))
                file_dir_name_label.pack()

        # Perform the actual scan on the selected file or directory
        def perform_scan():
            if file_dir_name_label:
                selected_path = file_dir_name_label.cget("text")
                if os.path.isfile(selected_path):
                    # Scan the selected file
                    if not scanner.scan_file(selected_path):
                        messagebox.showinfo("Scan Result", "No malicious content detected in the file.")
                elif os.path.isdir(selected_path):
                    # Scan the selected directory
                    scanner.scan_directory(selected_path)
                else:
                    messagebox.showwarning("Invalid Path", "Selected path is neither a file nor a directory.")
            else:
                messagebox.showwarning("Ooops", "No file or directory selected for scanning")

        # Create a button with the given text and command
        def create_button(parent, text, command):
            button = tk.Button(parent, text=text, font=('Bold', 15), fg='#158aff', bd=0, bg='#c3c3c3', command=command)
            button.pack(pady=10, fill=tk.X)

        create_button(scan_frame, 'Select File/Folder', choose_file_or_directory)
        create_button(scan_frame, 'Scan Now', perform_scan)

    # Page for real-time protection
    def RTP_page():
        global status_var

        RTP_frame = tk.Frame(main_frame)
        RTP_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        lb = tk.Label(RTP_frame, text='Real-Time Protection', font=('Bold', 30))
        lb.pack()

        # Choose a directory to monitor for real-time protection
        def choose_protect_directory():
            global path
            path = filedialog.askdirectory(title="Select Directory to Protect")
            if path:
                messagebox.showinfo("Selected Directory", f"Monitoring will be started for: {path}")

        select_directory_button = ttk.Button(RTP_frame, text="Select Directory to Protect", command=choose_protect_directory)
        select_directory_button.pack(pady=10)

        # Set up TreeView for displaying file system events
        columns = ("action", "path", "timestamp")
        treeview = ttk.Treeview(RTP_frame, columns=columns, show="headings")
        treeview.heading("action", text="Action")
        treeview.heading("path", text="Path")
        treeview.heading("timestamp", text="Timestamp")
        treeview.column("action", width=100)
        treeview.column("path", width=400)
        treeview.column("timestamp", width=150)
        treeview.pack(fill=tk.BOTH, expand=True)

        status_var = tk.StringVar()
        status_var.set("Monitoring stopped")
        status_label = ttk.Label(RTP_frame, textvariable=status_var)
        status_label.pack(pady=5)

        # Create buttons for starting and stopping monitoring
        button_frame = ttk.Frame(RTP_frame)
        button_frame.pack(pady=10)

        start_button = ttk.Button(button_frame, text="Start Monitoring", command=lambda: start_observing(treeview))
        start_button.pack(side=tk.LEFT, padx=5)

        stop_button = ttk.Button(button_frame, text="Stop Monitoring", command=stop_observing)
        stop_button.pack(side=tk.LEFT, padx=5)

        # Handle window closing event
        def on_closing():
            stop_observing()
            root.destroy()

        root.protocol("WM_DELETE_WINDOW", on_closing)

    # Quit the application
    def quit_application():
        root.quit()

    # Remove all pages from the main frame
    def delete_pages():
        for frame in main_frame.winfo_children():
            frame.destroy()

    # Hide the indicators on the option panel
    def hide_indicators():
        scan_indicate.config(bg='#c3c3c3')
        RTP_indicate.config(bg='#c3c3c3')
        quit_indicate.config(bg='#c3c3c3')

    # Highlight the selected option and display the corresponding page
    def indicate(lb, page):
        hide_indicators()
        lb.config(bg='#158aff')
        delete_pages()
        page()

    # Set up the option panel with buttons
    option_frame = tk.Frame(root, bg='#c3c3c3')
    option_frame.pack(side=tk.LEFT, fill=tk.Y)

    scan_indicate = tk.Label(option_frame, text='', bg='#c3c3c3')
    scan_indicate.grid(row=1, column=0, sticky='ew', padx=5, pady=5)

    RTP_indicate = tk.Label(option_frame, text='', bg='#c3c3c3')
    RTP_indicate.grid(row=2, column=0, sticky='ew', padx=5, pady=5)

    quit_indicate = tk.Label(option_frame, text='', bg='#c3c3c3')
    quit_indicate.grid(row=3, column=0, sticky='ew', padx=5, pady=5)

    # Create option buttons on the panel
    def create_option_button(text, command, row):
        button = tk.Button(option_frame, text=text, font=('Bold', 15), fg='#158aff', bd=0, bg='#c3c3c3', command=command)
        button.grid(row=row, column=1, padx=5, pady=5, sticky='ew')

    create_option_button('Scan', lambda: indicate(scan_indicate, scan_page), 1)
    create_option_button('Real-Time', lambda: indicate(RTP_indicate, RTP_page), 2)
    create_option_button('Quit', quit_application, 3)

    # Main frame where pages are displayed
    main_frame = tk.Frame(root, highlightbackground='black', highlightthickness=2)
    main_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

    # Set default page to 'Scan'
    indicate(scan_indicate, scan_page)

    root.mainloop()

# Run the GUI application with the given YARA rules directory
if __name__ == "__main__":
    rules_directory = r"C:\Users\sulav\OneDrive\Desktop\Python\Coursework1\rules"
    scanner = MalwareScanner(rules_directory)
    GUI()
